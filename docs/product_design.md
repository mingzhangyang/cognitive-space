# 认知型笔记应用 v0.1 产品设计文档

> 这是一个为“外部化思考”而生的个人应用，而不是一个笔记管理工具。

---

## 一、产品目标（Why）

### 1. 核心目标

* 帮助用户将**正在进行中的思考**外部化
* 让问题、判断和证据自然聚合，形成**认知数据库**
* 降低“整理、分类、管理”的心理成本
* 避免系统替代用户思考，而是**陪伴问题本身**

### 2. 非目标（明确不做）

* 不做文档管理工具
* 不追求高效产出或任务完成
* 不做强提醒、打卡、生产力工具
* 不以协作或分享为核心价值

---

## 二、核心理念（Philosophy）

### 1. 对“笔记”的重新定义

> 笔记不是内容的容器，而是**思考的痕迹**。

### 2. 三个设计公理

1. **写作必须完全自由**（无结构强加）
2. **结构延迟显现**（结构是结果，不是过程）
3. **系统不创造注意力，只利用已存在的注意力**

---

## 三、核心认知模型（What）

### 1. 最小认知单元

#### ① 问题（Question）

* 定义：仍在困扰用户的开放性疑问
* 特征：

  * 可长期存在
  * 允许无答案
  * 是系统的“引力中心”

#### ② 判断 / 主张（Claim）

* 定义：用户在某一时刻形成的暂时立场
* 特征：

  * 可悬空
  * 可被推翻
  * 不要求完整

#### ③ 证据（Evidence）

* 定义：支持或反驳判断的事实、经验、推理
* 特征：

  * 可正向或反向
  * 可来自不同时间

#### ④ 触发物（Trigger）

* 定义：诗句、哲理、片段感受、灵感
* 特征：

  * 不强制结构
  * 可被“激活”为问题或证据
  * 允许长期游离

---

## 四、系统行为逻辑（How）

### 1. 写作行为

* 用户进入写作界面：

  * 不提示类型
  * 不要求选择归属
  * 不显示结构

* 所有输入默认为“自由文本”

* 系统在后台进行语义分析

### 2. 结构显现机制（延迟显现）

* 写作完成后，系统：

  * 尝试推断其可能角色（问题 / 判断 / 证据 / 触发物）
  * 但**不立即打断或要求确认**

* 结构在以下时机显现：

  * 用户回看某个问题
  * 用户主动整理
  * 新写作与旧问题产生高度相关

### 3. 轻声提示原则（B 模式）

* 系统只在“语义高度相关”时提示
* 提示形式：

  * 非弹窗
  * 可忽略

示例：

> “你现在写的内容，可能与问题「X」有关。要看一眼吗？”

---

## 五、核心界面结构（体验级，而非视觉）

### 1. 首页（唯一首页）

* 内容：

  * 当前仍然“活着”的问题列表

* 排序逻辑：

  * 最近被触及
  * 最近被相关内容靠近

* 唯一主行动：

  * 「写」

---

### 2. 写作界面

* 极简输入区域
* 无类型选择
* 无层级
* 写完即存在

目标体验：

> 像把想法丢进一个安全的思考空间

---

### 3. 问题视图（认知剖面）

当用户进入一个问题：

* 展示内容不是总结文档，而是：

  * 相关判断（按时间或强度）
  * 支撑 / 反驳的证据
  * 尚未吸收的触发物

这是一个**思考现场的横截面**。

---

## 六、用户使用流程（Flow）

1. 打开 App
2. 看到仍在困扰的问题
3. 点击「写」，记录任何内容
4. 系统后台分析、慢慢聚合
5. 当相关性出现 → 轻声提示
6. 用户在需要时回到问题现场

---

## 七、v0.1 范围界定

### 包含

* 单用户
* 本地 / 私有优先
* 问题驱动首页
* 自由写作 + 延迟结构

### 不包含

* 协作
* 分享
* 模板
* 标签系统
* 任务 / Todo
* 强提醒

---

## 八、产品自我约束（写给未来的自己）

* 不要为了“好用”牺牲思考自由
* 不要为了“智能”替代用户判断
* 不要为了“完整”强迫收敛

> 这是一个允许问题长期存在的系统。
> 如果某个问题被放弃，那也是思考的一部分。

---

## 九、产品一句话定义

> **我不是在记录想法，我是在陪伴问题。**

---

## v0.1 Event Types（事件类型清单）

（见上一节，略）

---

## v0.1 Reducer 设计文档（State Projection & Reducer Logic）

### 1. 文档定位

本文件定义：**如何从事件流（Event Stream）投影出“可被界面与用户感知的思考状态”**。

Reducer 不是智能体，不进行推理、裁决或建议，仅负责：

* 保证状态一致性
* 维护思考阶段与张力
* 支持完全可重放

---

### 2. Reducer 的核心设计原则

1. **Reducer 不理解意义，只记录关系**
2. **Reducer 不制造结论，只反映当前立场**
3. **Reducer 永远是纯函数：State = f(Events)**
4. **任何“智能行为”必须以事件形式显式进入系统**

---

### 3. 投影状态模型（Projected State）

Reducer 的输出不是数据库模型，而是“当前思考形态”的投影。

```ts
State {
  questions: Map<QuestionID, {
    wording: string
    status: 'active' | 'paused'
    judgments: Set<JudgmentID>
    lastTouchedAt: timestamp
  }>

  judgments: Map<JudgmentID, {
    wording: string
    status: 'active' | 'suspended'
    evidence: Set<EvidenceID>
    stanceStrength?: number
  }>

  evidence: Map<EvidenceID, {
    text: string
    polarity: 'support' | 'oppose' | 'neutral'
    disputed: boolean
  }>

  triggers: Map<TriggerID, {
    text: string
    activated: boolean
  }>

  focus: {
    currentQuestion?: QuestionID
  }

  tension: {
    unresolvedContradictions: Set<ContradictionID>
  }
}
```

---

### 4. Reducer 生命周期

1. 读取事件流（按时间排序）
2. 初始化空 State
3. 逐条事件调用 reducer(event, state)
4. 输出最终 State

任何时刻的状态都可以通过**完整或部分事件回放**获得。

---

### 5. 关键 Reducer 行为定义

#### 5.1 RawInputAdded

* 不创建结构性状态
* 仅更新时间与活动记录

**设计理由**：保证书写过程完全无干扰。

---

#### 5.2 QuestionDeclared

* 创建 Question 节点
* 若无当前焦点问题，则自动设为 focus

该行为定义了“当前我在思考什么”。

---

#### 5.3 JudgmentDeclared

* 创建 Judgment 节点
* 不强制绑定问题

判断允许悬浮，避免过早归因。

---

#### 5.4 JudgmentLinkedToQuestion

* 在 Question 与 Judgment 之间建立关系

Reducer 不判断合理性，仅承认关系存在。

---

#### 5.5 EvidenceLinkedToJudgment

* 将 Evidence 纳入某判断的支持 / 反对结构

证据不会“完成”，只会被补充或质疑。

---

#### 5.6 JudgmentSuspended

* 将判断状态设为 suspended

这是系统对“立场撤回”的唯一表达方式。

---

#### 5.7 QuestionReframed

* 旧问题进入非活跃状态
* 创建新问题
* 原判断可软迁移
* 新问题成为当前焦点

体现“我可能一开始就问错了问题”。

---

#### 5.8 ContradictionDetected（系统事件）

* 在 tension 区域登记冲突

Reducer 不解决冲突，只保存张力。

---

#### 5.9 ThinkingPaused / ThinkingResumed

* 修改问题状态
* 必要时清空 / 恢复 focus

暂停不是失败，而是阶段。

---

### 6. Reducer 的非职责范围（明确禁止）

Reducer 不允许：

* 自动生成判断或证据
* 自动合并 / 删除问题
* 自动解决冲突
* 自动提示下一步行动

所有以上行为若发生，必须通过**显式事件**进入系统。

---

### 7. 对界面的约束意义

任何界面都只能使用 Reducer 输出的 State：

* 不允许绕过 reducer 直接计算“重要性”
* 不允许隐式制造完成态
* 不允许隐藏 suspended / paused 状态

界面只是 State 的一种观察方式。

---

### 8. 设计总结

Reducer 的存在不是为了效率，而是为了**忠实保存思考的真实轨迹**。

它保证：

* 思考可以反悔
* 判断可以悬空
* 冲突可以长期存在
* 过去的自己不会被覆盖

这不是技术妥协，而是认知立场。

---

## 路线 3｜反设计文档：这个应用永远不会做的 20 件事

本文件不是功能规划，而是**边界宣言**。
它用于防止产品在未来演进中，背叛其最初的认知立场。

---

### 一、关于结构与管理（1–6）

1. **不会引入文件夹 / 目录树作为核心入口**
   思考不是层级化存储问题。

2. **不会要求用户主动管理结构**
   系统允许混乱在前，结构在后。

3. **不会以“文档”为基本单位**
   只有问题、判断、证据、触发物。

4. **不会强制任何模板或填写顺序**
   模板会反向塑造思考。

5. **不会要求“完成一个问题”**
   思考允许长期未完成。

6. **不会以“整洁度”作为价值指标**
   混乱不等于低质量。

---

### 二、关于智能与自动化（7–12）

7. **不会自动生成判断或结论**
   系统不替你下判断。

8. **不会自动补全证据链**
   证据必须被你承认。

9. **不会给出“下一步你应该做什么”**
   那是意志让渡。

10. **不会自动消解冲突**
    冲突是认知资产。

11. **不会把 AI 作为对话对象存在于前台**
    AI 只在后台提示结构张力。

12. **不会用评分 / 进度条表示思考质量**
    思考不可量化。

---

### 三、关于效率与生产力叙事（13–16）

13. **不会以“更快写完”为目标**
    慢是被允许的。

14. **不会鼓励“日更 / 连续打卡”**
    频率不是价值。

15. **不会把思考结果直接转化为 KPI / 输出**
    思考不是流水线。

16. **不会用“生产力提升”作为核心卖点**
    这是认知工具，不是效率工具。

---

### 四、关于用户与自我关系（17–20）

17. **不会诱导用户依赖系统进行思考**
    系统只是容器，不是大脑。

18. **不会隐藏你过去的错误判断**
    反悔是历史的一部分。

19. **不会美化或重写你的思考轨迹**
    真实优于连贯叙事。

20. **不会把“你”简化成一个画像或标签**
    你是变化中的。

---

### 结语

这 20 条不是限制，而是保护。

它们保护：

* 你的迟疑
* 你的反复
* 你的悬而未决
* 你不被工具塑形的权利

当未来的你想要“加一个看起来很合理的功能”时，
请先回来读这一页。
